<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序省市区三级联动优化版]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9C%81%E5%B8%82%E5%8C%BA%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%E4%BC%98%E5%8C%96%E7%89%88%2F</url>
    <content type="text"><![CDATA[优化版的省市区选择器，更简化的Js数据，方便输出以及读取显示。js地址：城市数据js。 页面组件： 123&lt;picker mode=&quot;multiSelector&quot; bindchange=&quot;bindMultiPickerChange&quot; bindcolumnchange=&quot;bindMultiPickerColumnChange&quot; value=&quot;&#123;&#123;citiesIndex&#125;&#125;&quot; range=&quot;&#123;&#123;cityArray&#125;&#125;&quot; range-key=&quot;name&quot;&gt; &lt;/picker&gt; js优化后无需放服务器请求，放本地即可。 1.加载城市数据1var array = require(&apos;../../../utils/cityData.js&apos;).cityData; 2.选择器数据初始化初始化选择器数据，默认都选中第一项。 123456789101112131415161718192021222324252627282930let cityArray = [ [], [], []];for (let x in array[&quot;86&quot;]) &#123; //存入省 cityArray[0].push(&#123; name: array[&quot;86&quot;][x], code: x &#125;);&#125;for (let y in array[cityArray[0][0].code]) &#123; //存入市，默认关联第一个省 cityArray[1].push(&#123; name: array[cityArray[0][0].code][y], code: y &#125;);&#125;for (let z in array[cityArray[1][0].code]) &#123; //存入区，默认关联第一个省的第一个市 cityArray[2].push(&#123; name: array[cityArray[1][0].code][z], code: z &#125;);&#125;this.setData(&#123; cityArray: cityArray&#125;); 3.列滚动事件滚动选择器的列时相应的数据变化，这是最重要的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//列滚动事件 bindMultiPickerColumnChange(e) &#123; let selectedIndex = e.detail.value; let cityArray = this.data.cityArray; let list1 = []; //存放第二列数据，即市的列 let list2 = []; //存放第三列数据，即区的列 let citiesIndex = []; let pcode = &apos;&apos;, scode = &apos;&apos;; let provinceIndex = this.data.citiesIndex[0]; //选中的省索引 let cityIndex = this.data.citiesIndex[1]; //选中的市索引 let areaIndex = this.data.citiesIndex[2]; //选中的区索引 switch (e.detail.column) &#123; case 0: //滚动第一列 pcode = cityArray[0][selectedIndex].code; for(let x in array[pcode])&#123; list1.push(&#123; name: array[pcode][x], code: x &#125;); &#125; scode = list1[0].code; for(let y in array[scode])&#123; list2.push(&#123; name: array[scode][y], code: y &#125;); &#125; citiesIndex = [selectedIndex, 0, 0, 0]; break; case 1: //滚动第二列 list1 = cityArray[1]; scode = list1[selectedIndex].code; for(let x in array[scode])&#123; list2.push(&#123; name: array[scode][x], code: x &#125;); &#125; citiesIndex = [provinceIndex, selectedIndex, 0, 0]; break; case 2: //滚动第三列 list1 = cityArray[1]; list2 = cityArray[2]; citiesIndex = [provinceIndex, cityIndex, selectedIndex, 0]; break; &#125; this.setData(&#123; [`cityArray[1]`]: list1, //重新赋值第二列数组，即联动了市 [`cityArray[2]`]: list2, //重新赋值第三列数组，即联动了区 citiesIndex: citiesIndex, //更新索引 &#125;); 4.选择器变更事件12345678910111213141516171819202122//选择器选择事件 bindMultiPickerChange(e) &#123; let cityIndex = e.detail.value; let cityArray = this.data.cityArray; let province = cityArray[0][cityIndex[0]].name; let city = cityArray[1][cityIndex[1]].name; let district = cityArray[2][cityIndex[2]].name; //选择的地址编码 let areaCode = cityArray[2][cityIndex[2]].code; //选择的地址文本 let selectedAddress = &quot;&quot;; selectedAddress = province + city + district; this.setData(&#123; region: selectedAddress, areaCode: areaCode, provinceCode: cityArray[0][cityIndex[0]].code, cityCode: cityArray[1][cityIndex[1]].code &#125;); &#125;, #5.根据传过来的值显示省市区 修改初始化选择器方法，判断当修改地址时读取显示已选择的省市区。 12345678910111213141516171819202122232425262728293031323334353637383940for (let x in array[&quot;86&quot;]) &#123; //存入省 cityArray[0].push(&#123; name: array[&quot;86&quot;][x], code: x &#125;);&#125;if(this.data.address_id != &quot;&quot;)&#123; //编辑地址，根据传过来的地址文本和编码调整选择器 for (let y in array[provinceCode]) &#123; cityArray[1].push(&#123; name: array[provinceCode][y], code: y &#125;); &#125; for (let z in array[cityCode]) &#123; cityArray[2].push(&#123; name: array[cityCode][z], code: z &#125;); &#125; for(let i = 0,len = cityArray[0].length;i&lt;len;i++)&#123; if (cityArray[0][i].code == provinceCode) &#123; provinceIndex = i; &#125; &#125; for (let j = 0, len = cityArray[1].length; j &lt; len; j++) &#123; if (cityArray[1][j].code == cityCode) &#123; cityIndex = j; &#125; &#125; for (let k = 0, len = cityArray[2].length; k &lt; len; k++) &#123; if (cityArray[2][k].code == areaCode) &#123; districtIndex = k; &#125; &#125;&#125; else &#123; //添加地址 效果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序长按数量自动加减]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%95%BF%E6%8C%89%E6%95%B0%E9%87%8F%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[开发一个微信小程序，有购物车的功能，在测试加减购物车中商品数量时，发现点一下加一或减一太烦，于是添加了长按自动加减的功能。 页面组件 123&lt;text class="minus" catchtouchstart='startMinus' catchtouchend='endMinus' data-index="&#123;&#123;index&#125;&#125;" data-goodIndex="&#123;&#123;goodIndex&#125;&#125;"&gt;-&lt;/text&gt; &#123;&#123;good.num&#125;&#125; &lt;!-- 商品数量 --&gt;&lt;text class="add" catchtouchstart='startAdd' catchtouchend='endAdd' data-index="&#123;&#123;index&#125;&#125;" data-goodIndex="&#123;&#123;goodIndex&#125;&#125;"&gt;+&lt;/text&gt; 1.监听触摸开始事件首先监听触摸开始事件touchstart，记录触摸开始时间，时间后面有用。需要用到定时器，timer用的是页面全局变量。 123456789101112131415161718192021222324//按住加号不停地加startAdd(e)&#123; startTime = new Date().getTime(); //记录触摸开始时间 let index = e.currentTarget.dataset.index; let goodIndex = e.currentTarget.dataset.goodindex; timer = setInterval(()=&gt;&#123; //定义定时器 this.data.cartList[index].goodList[goodIndex].num++; let sumPrice = 0; let count = 0; this.data.cartList.map((type, index) =&gt; &#123; type.goodList.map((good, index) =&gt; &#123; count += good.num; //计算商品数量 if (good.selected) &#123; //计算选中商品价格 sumPrice += good.price * good.num; &#125; &#125;); &#125;); this.setData(&#123; [`cartList[$&#123;index&#125;].goodList[$&#123;goodIndex&#125;]`]: this.data.cartList[index].goodList[goodIndex], //购物车列表内容局部刷新 goodSumPrice: sumPrice, cartNum: count &gt; 99 ? '99+' : count &#125;); &#125;, 100);&#125; 2.监听触摸结束事件触摸结束，则结束数量加减，清除定时器。记录结束时间，和开始时间比较，根据微信小程序官方文档定义：手指触摸后，超过350ms再离开为长按。反之则认为是点击，执行点击的逻辑，即数量加一。 12345678//结束加endAdd(e)&#123; endTime = new Date().getTime(); //记录结束时间 if((endTime - startTime) &lt; 350000)&#123; this.clickAdd(e); &#125; clearInterval(timer);&#125; 点击事件逻辑：123456789101112131415161718192021//点击加号clickAdd(e)&#123; let index = e.currentTarget.dataset.index; let goodIndex = e.currentTarget.dataset.goodindex; this.data.cartList[index].goodList[goodIndex].num ++; let sumPrice = 0; let count = 0; this.data.cartList.map((type, index) =&gt; &#123; type.goodList.map((good, index) =&gt; &#123; count += good.num; if (good.selected) &#123; sumPrice += good.price * good.num; &#125; &#125;); &#125;); this.setData(&#123; [`cartList[$&#123;index&#125;].goodList[$&#123;goodIndex&#125;]`]: this.data.cartList[index].goodList[goodIndex], goodSumPrice: sumPrice, cartNum: count&gt;99?'99+':count &#125;);&#125; 之所以要判断是长按还是点击是因为在标签元素上定义了触摸开始事件后，tap事件就不再触发，所以需要手动调用点击方法。 减号同理，需要注意数量减到0时的操作，我的逻辑是长按数量减到一就停止，再点击减号则删除该商品。 效果图]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序省市区街道四级联动带区域编码]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9C%81%E5%B8%82%E5%8C%BA%E8%A1%97%E9%81%93%E5%9B%9B%E7%BA%A7%E8%81%94%E5%8A%A8%E5%B8%A6%E5%8C%BA%E5%9F%9F%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[微信小程序利用picker多列选择器自定义的省市区街道选择器，输出地址文本以及对应的地区编码。 首先需要城市的数据，由于微信小程序有2M的限制，而且城市数据的js已经接近2M了，所以放到服务器上，用时请求即可。为了方便数据处理，js里面就是一个json数组，省是最外层，然后市区街道都存对应的children数组里。这里附上js：城市数据js 页面组件： 123&lt;picker mode=&quot;multiSelector&quot; bindchange=&quot;bindMultiPickerChange&quot; bindcolumnchange=&quot;bindMultiPickerColumnChange&quot; value=&quot;&#123;&#123;citiesIndex&#125;&#125;&quot; range=&quot;&#123;&#123;cityArray&#125;&#125;&quot; range-key=&quot;name&quot;&gt; &lt;/picker&gt; 1.加载城市数据首次进入页面时发请求加载，加载过就存入缓存，避免重复加载。 12345678910111213141516onLoad: function (options) &#123; var that = this; if(wx.getStorageSync(&quot;cityData&quot;))&#123; array = wx.getStorageSync(&quot;cityData&quot;); that.initData(); &#125; else &#123; wx.request(&#123; url: &apos;https://wxapi.xinglinjiuye.cn/js/cityData.js&apos;, success: res =&gt; &#123; array = res.data; wx.setStorageSync(&quot;cityData&quot;, res.data); that.initData(); &#125; &#125;); &#125; &#125;, 2.选择器数据初始化初始化选择器数据，默认都选中第一项。 1234567891011121314151617181920212223242526272829303132initData: function()&#123; let cityArray = [[], [], [], []]; //选择器数据 for (let i = 0, len = array.length; i &lt; len; i++) &#123; //存入省 cityArray[0].push(&#123; name: array[i].name, code: array[i].code &#125;); &#125; for (let j = 0, len = array[0].children.length; j &lt; len; j++) &#123; //存入市，默认关联第一个省 cityArray[1].push(&#123; name: array[0].children[j].name, code: array[0].children[j].code &#125;); &#125; for (let k = 0, len = array[0].children[0].children.length; k &lt; len; k++) &#123; //存入区，默认关联第一个省的第一个市 cityArray[2].push(&#123; name: array[0].children[0].children[k].name, code: array[0].children[0].children[k].code &#125;); &#125; for (let s = 0, len = array[0].children[0].children[0].children.length; s &lt; len; s++) &#123; //存入街道，默认关联第一个省的第一个市的第一个区 cityArray[3].push(&#123; name: array[0].children[0].children[0].children[s].name, code: array[0].children[0].children[0].children[s].code &#125;); &#125; this.setData(&#123; cityArray: cityArray &#125;); &#125; 3.列滚动事件滚动选择器的列时相应的数据变化，这是最重要的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//列滚动事件 bindMultiPickerColumnChange(e)&#123; let selectedIndex = e.detail.value; //滚动到哪一项 let cityArray = this.data.cityArray; let list1 = []; //存放第二列数据，即市的列 let list2 = []; //存放第三列数据，即区的列 let list3 = []; //存放第四例数据，即街道的列 let citiesIndex = []; let provinceIndex = this.data.citiesIndex[0]; //选中的省索引 let cityIndex = this.data.citiesIndex[1]; //选中的市索引 let areaIndex = this.data.citiesIndex[2]; //选中的区索引 switch (e.detail.column) &#123; //判断滚动的哪一列并做相应的数据处理 case 0: //滚动第一列，即省的那一列 for(let i = 0,len = array[selectedIndex].children.length;i&lt;len;i++)&#123; //存入省下面的市 list1.push(&#123; name: array[selectedIndex].children[i].name, code: array[selectedIndex].children[i].code &#125;); &#125; for (let j = 0, len = array[selectedIndex].children[0].children.length; j &lt; len; j++) &#123; //存入市下面的区 list2.push(&#123; name: array[selectedIndex].children[0].children[j].name, code: array[selectedIndex].children[0].children[j].code &#125;); &#125; for (let k = 0, len = array[selectedIndex].children[0].children[0].children.length; k &lt; len; k++) &#123;//存入区下面的街道 list3.push(&#123; name: array[selectedIndex].children[0].children[0].children[k].name, code: array[selectedIndex].children[0].children[0].children[k].code &#125;); &#125; citiesIndex = [selectedIndex, 0, 0, 0]; //记录索引 break; case 1: //滚动第二列，即市的那一列 list1 = cityArray[1]; //市那一列数据不需要更新 for(let i = 0,len = array[provinceIndex].children[selectedIndex].children.length;i&lt;len;i++)&#123;//存入市下面的区 list2.push(&#123; name: array[provinceIndex].children[selectedIndex].children[i].name, code: array[provinceIndex].children[selectedIndex].children[i].code &#125;); &#125; if (array[selectedIndex].children.length &gt; 0) &#123; //判断是否有子节点，城市数据里有的城市没有下属的区县 for (let j = 0, len = array[selectedIndex].children[0].children.length; j &lt; len; j++) &#123; list2.push(&#123; name: array[selectedIndex].children[0].children[j].name, code: array[selectedIndex].children[0].children[j].code &#125;); &#125; if (array[selectedIndex].children[0].children.length &gt; 0)&#123; for (let k = 0, len = array[selectedIndex].children[0].children[0].children.length; k &lt; len; k++) &#123; list3.push(&#123; name: array[selectedIndex].children[0].children[0].children[k].name, code: array[selectedIndex].children[0].children[0].children[k].code &#125;); &#125; &#125; &#125; citiesIndex = [provinceIndex, selectedIndex, 0, 0]; //记录索引 break; case 2: //滚动第三列，即区的那一列 list1 = cityArray[1]; //市和区的数据都需要更新 list2 = cityArray[2]; if (array[provinceIndex].children[selectedIndex].children.length &gt; 0) &#123; for (let j = 0, len = array[provinceIndex].children[selectedIndex].children[0].children.length; j &lt; len; j++) &#123; list3.push(&#123; name: array[provinceIndex].children[selectedIndex].children[0].children[j].name, code: array[provinceIndex].children[selectedIndex].children[0].children[j].code &#125;); &#125; &#125; citiesIndex = [provinceIndex, cityIndex, selectedIndex, 0]; //记录索引 break; case 3: //滚动第四列，即街道那一列 list1 = cityArray[1]; list2 = cityArray[2]; list3 = cityArray[3]; citiesIndex = [provinceIndex, cityIndex, areaIndex, selectedIndex]; //记录索引 break; &#125; this.setData(&#123; [`cityArray[1]`]: list1,//重新赋值第二列数组，即联动了市 [`cityArray[2]`]: list2,//重新赋值第三列数组，即联动了区 [`cityArray[3]`]: list3,//重新赋值第四列数组，即联动了街道 citiesIndex: citiesIndex,//更新索引 &#125;); &#125; 4.选择器变更事件1234567891011121314151617181920212223242526272829//选择器选择事件 bindMultiPickerChange(e)&#123; let cityIndex = e.detail.value; let province = array[cityIndex[0]].name; let city = array[cityIndex[0]].children[cityIndex[1]].name; let district = &apos;&apos;, street = &apos;&apos;; //选择的地址编码 let areaCode = &quot;&quot;; //选择的地址文本 let selectedAddress = &quot;&quot;; if (array[cityIndex[0]].children[cityIndex[1]].children.length &gt; 0) &#123; district = array[cityIndex[0]].children[cityIndex[1]].children[cityIndex[2]].name; &#125; else &#123; areaCode = array[cityIndex[0]].children[cityIndex[1]].code; selectedAddress = province + city; return; &#125; if (array[cityIndex[0]].children[cityIndex[1]].children[cityIndex[2]].children.length &gt; 0) &#123; street = array[cityIndex[0]].children[cityIndex[1]].children[cityIndex[2]].children[cityIndex[3]].name; &#125; else &#123; areaCode = array[cityIndex[0]].children[cityIndex[1]].children[cityIndex[2]].code; selectedAddress = province + city + district; return; &#125; selectedAddress = province + city + district + street; areaCode = array[cityIndex[0]].children[cityIndex[1]].children[cityIndex[2]].children[cityIndex[3]].code; &#125;, 效果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
