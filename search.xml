<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React知识点]]></title>
    <url>%2F2020%2F08%2F03%2FReact%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[# 1. React 生命周期有哪些，16 版本生命周期发生了哪些变化？ # 15 生命周期 初始化阶段 constructor 构造函数 getDefaultPropsprops 默认值 getInitialStatestate 默认值 挂载阶段 componentWillMount 组件初始化渲染前调用 render 组件渲染 componentDidMount 组件挂载到 DOM 后调用 更新阶段 componentWillReceiveProps 组件将要接收新 props 前调用 shouldComponentUpdate 组件是否需要更新 componentWillUpdate 组件更新前调用 render 组件渲染 componentDidUpdate 组件更新后调用 卸载阶段 componentWillUnmount 组件卸载前调用 # 16 生命周期 初始化阶段 constructor 构造函数 getDefaultPropsprops 默认值 getInitialStatestate 默认值 挂载阶段 static getDerivedStateFromProps(props,state) render componentDidMount getDerivedStateFromProps：组件每次被 rerender 的时候，包括在组件构建之后 (虚拟 dom 之后，实际 dom 挂载之前)，每次获取新的 props 或 state 之后；每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state；配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法。 更新阶段 static getDerivedStateFromProps(props,state) shouldComponentUpdate render getSnapshotBeforeUpdate(prevProps,prevState) componentDidUpdate getSnapshotBeforeUpdate：触发时间: update 发生的时候，在 render 之后，在组件 dom 渲染之前；返回一个值，作为 componentDidUpdate 的第三个参数；配合 componentDidUpdate, 可以覆盖 componentWillUpdate 的所有用法。 卸载阶段 componentWillUnmount 错误处理 componentDidCatch React16 新的生命周期弃用了 componentWillMount、componentWillReceivePorps，componentWillUpdate 新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate 来代替弃用的三个钩子函数。 React16 并没有删除这三个钩子函数，但是不能和新增的钩子函数混用， React17 将会删除这三个钩子函数，新增了对错误的处理（ componentDidCatch）。 # 2. setState 是同步的还是异步的？ 生命周期和合成事件中 在 React 的生命周期和合成事件中， React 仍然处于他的更新机制中，这时无论调用多少次 setState，都会不会立即执行更新，而是将要更新的・存入 _pendingStateQueue，将要更新的组件存入 dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 didmount 后会将批处理标志设置为 false。这时将取出 dirtyComponent 中的组件以及 _pendingStateQueue 中的 state 进行更新。这样就可以确保组件不会被重新渲染多次。 123456componentDidMount() &#123;this.setState(&#123; index: this.state.index + 1&#125;)console.log(&apos;state&apos;, this.state.index);&#125; 所以，如上面的代码，当我们在执行 setState 后立即去获取 state，这时是获取不到更新后的 state 的，因为处于 React 的批处理机制中， state 被暂存起来，待批处理机制完成之后，统一进行更新。 所以。setState 本身并不是异步的，而是 React 的批处理机制给人一种异步的假象。 异步代码和原生事件中 123456789componentDidMount() &#123; setTimeout(() =&gt; &#123; console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); &#125;, 0);&#125; 如上面的代码，当我们在异步代码中调用 setState 时，根据 JavaScript 的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，这时 React 的批处理机制已经走完，处理标志设被设置为 false，这时再调用 setState 即可立即执行更新，拿到更新后的结果。 在原生事件中调用 setState 并不会出发 React 的批处理机制，所以立即能拿到最新结果。 最佳实践 setState 的第二个参数接收一个函数，该函数会在 React 的批处理机制完成之后调用，所以你想在调用 setState 后立即获取更新后的值，请在该回调函数中获取。 123this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index);&#125;) 链接：由实际问题探究 setState 的执行机制。 # 3. 为什么有时连续多次 setState 只有一次生效？ 例如下面的代码，两次打印出的结果是相同的： 12345678componentDidMount() &#123; this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 原因就是 React 会批处理机制中存储的多个 setState 进行合并，来看下 React 源码中的 _assign 函数，类似于 Object 的 assign： 如果传入的是对象，很明显会被合并成一次，所以上面的代码两次打印的结果是相同的： 12345Object.assign( nextState,&#123;index: state.index+ 1&#125;,&#123;index: state.index+ 1&#125;) 注意， assign 函数中对函数做了特殊处理，处理第一个参数传入的是函数，函数的参数 preState 是前一次合并后的结果，所以计算结果是准确的： 123456789101112componentDidMount() &#123; this.setState((state, props) =&gt; (&#123; index: state.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;) this.setState((state, props) =&gt; (&#123; index: state.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 所以上面的代码两次打印的结果是不同的。 最佳实践 React 会对多次连续的 setState 进行合并，如果你想立即使用上次 setState 后的结果进行下一次 setState，可以让 setState 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。 # 4. 虚拟 Dom 比普通 Dom 更快吗？ 很多文章说 VitrualDom 可以提升性能，这一说法实际上是很片面的。 直接操作 DOM 是非常耗费性能的，这一点毋庸置疑。但是 React 使用 VitrualDom 也是无法避免操作 DOM 的。 如果是首次渲染， VitrualDom 不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。 VitrualDom 的优势在于 React 的 Diff 算法和批处理策略， React 在页面更新之前，提前计算好了如何进行更新和渲染 DOM。实际上，这个计算过程我们在直接操作 DOM 时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如 React 好的。所以，在这个过程中 React 帮助我们 &quot;提升了性能&quot;。 所以，我更倾向于说， VitrualDom 帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比 DOM 操作更快。 # 5. 为什么代码中一定要引入 React？ JSX 只是为 React.createElement (component,props,…children) 方法提供的语法糖。 所有的 JSX 代码最后都会转换成 React.createElement (…)， Babel 帮助我们完成了这个转换的过程。 所以使用了 JSX 的代码都必须引入 React。 # 6. 为什么 React 组件首字母必须大写？ babel 在编译时会判断 JSX 中组件的首字母，当首字母为小写时，其被认定为原生 DOM 标签， createElement 的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement 的第一个变量被编译为对象。 # 7. React 在渲染真实 Dom 时做了哪些性能优化？ 在 IE（8-11）和 Edge 浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。 React 通过 lazyTree，在 IE（8-11）和 Edge 中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的 DOM 结构构建好，然后再整体插入容器。 并且，在单独渲染节点时， React 还考虑了 fragment 等特殊节点，这些节点则不会一个一个插入渲染。 # 8. Hook 有哪些优势？ 减少状态逻辑复用的风险 Hook 和 Mixin 在用法上有一定的相似之处，但是 Mixin 引入的逻辑和状态是可以相互覆盖的，而多个 Hook 之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用 HOC 也有可能带来一定冲突，比如 props 覆盖等等，使用 Hook 则可以避免这些问题。 避免地狱式嵌套 大量使用 HOC 的情况下让我们的代码变得嵌套层级非常深，使用 HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解 在使用 class 组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用 Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替 class 相比函数，编写一个 class 可能需要掌握更多的知识，需要注意的点也越多，比如 this 指向、绑定事件等等。另外，计算机理解一个 class 比理解一个函数更快。Hooks 让你可以在 classes 之外使用更多 React 的新特性。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Antv G2 4.0+技巧]]></title>
    <url>%2F2020%2F08%2F03%2F4-0-%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、无限可能的数据可视化最佳实践。网址：https://antv.vision/zh。 G2 一套面向常规统计图表，以数据驱动的高交互可视化图形语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。网址：https://g2.antv.vision/zh。 # 1. 设置图例 123456789101112131415legend(&#123; position: &apos;top-left&apos;, offsetX: 200, itemName: &#123; //设置图例文本 style: &#123; fontSize: 14, fill: &apos;#5F717D&apos;, x: 22, &#125;, &#125;, marker: &#123; //设置图例标注样式 style: &#123; r: 6, &#125;, &#125;, &#125;); 具体 style 属性参考：https://g2.antv.vision/zh/docs/api/interfaces/shapemarkerattrs。 # 2. 自定义图例点击事件，隐藏对应图形 1234567891011121314chartRef.current.on(&apos;legend:click&apos;, (ev: any) =&gt; &#123; const &#123; unchecked, value &#125; = ev.target.cfg.delegateObject.item; const geoms = chartRef.current.geometries; for (let i = 0; i &lt; geoms.length; i++) &#123; const geom = geoms[i]; if (geom.getYScale().field === value) &#123; if (!unchecked) &#123; geom.show(); &#125; else &#123; geom.hide(); &#125; &#125; &#125;&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端调用百度图片识别API]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%ABAPI%2F</url>
    <content type="text"><![CDATA[因为业务需求，有车牌识别的功能，所以上网找了图片识别的解决方案，发现 BAT 都有，但是百度的免费次数最多，对业务来说就相当于全免费了，所以就选择了百度的 API，😄。官方文档地址：https://ai.baidu.com/docs#/OCR-API/top。 # 1. 拍照获取图片 项目是 H5 APP，拍照用了 H5 + 的 api。 1234567891011121314151617//拍照captureImage() &#123; let _this = this; var cmr = plus.camera.getCamera(); var res = cmr.supportedImageResolutions[0]; //摄像头支持的拍照分辨率 var fmt = cmr.supportedImageFormats[0]; //摄像头支持的拍照文件格式 cmr.captureImage((path)=&gt; &#123; _this.convertUrl(path); &#125;, function(error) &#123; console.log(&quot;Capture image failed: &quot; + error.message); &#125;, &#123; resolution: res, format: fmt &#125; );&#125;, # 2. 图片转 base64 根据官方文档，图片要转成 base64 数据。 123456789101112131415161718192021222324//转换图片路径并调用方法识别convertUrl(path)&#123; let _this = this; //转换为本地文件路径 plus.io.resolveLocalFileSystemURL(path, function(entry) &#123; var localurl = entry.toLocalURL(); var reader = new plus.io.FileReader(); reader.onloadend = function (e) &#123; var imgData = e.target.result.replace(&quot;data:image/jpeg;base64,&quot;, &quot;&quot;).replace(&quot;data:image/png;base64,&quot;, &quot;&quot;);//base64图片 ocr.startOCR(imgData, res=&gt;&#123; var number = res.words_result.number; if(number.length == 7)&#123; uni.showToast(&#123; title: &quot;识别成功&quot;, icon: &quot;none&quot; &#125;) var values = number.split(&quot;&quot;); _this.result = values; &#125; &#125;); &#125;; reader.readAsDataURL(localurl); &#125;);&#125;, # 3. 获取 Access Token 好了，现在图片数据有了，在调百度车牌识别 API 之前还要先获取 Access Token, 而要获取 Access Token，又得先登记一个应用，取到应用的 API KEY 和 SECRET KEY。 12345678910111213141516171819202122232425//获取access_tokenfunction requestAccessToken(callback) &#123; let params = &#123; grant_type: &apos;client_credentials&apos;, //固定值 client_id: api_key, //登记应用的API KEY client_secret: secret_key //登记应用的SECRET KEY &#125; //network是封装的ajax请求函数 network.request(&apos;https://aip.baidubce.com/oauth/2.0/token&apos;, params, null, &quot;GET&quot;, res =&gt; &#123; if (res.hasOwnProperty(&apos;access_token&apos;)) &#123; let nowTime = new Date().getTime(); //记录当前请求时间是为了判断access_token是否过期 let access_token_obj = &#123; access_token: res.access_token, requestTime: nowTime &#125; uni.setStorageSync(&quot;access_token_obj&quot;, access_token_obj) callback(res.access_token); &#125; else &#123; //获取access_token失败 console.log(JSON.stringify(res)); &#125; &#125;);&#125; # 4. 调用车牌识别 API 先判断之前是否请求过 access_token，如果请求过再判断 access_token 是否过期。 12345678910111213141516171819202122/** * 开始进行文字识别，传入base64图片数据和回调函数 */function startOCR(imgData, callback) &#123; console.log(&quot;开始识别...&quot;); console.log(&quot;access_token缓存？&quot; + uni.getStorageSync(&quot;access_token_obj&quot;)); if (uni.getStorageSync(&quot;access_token_obj&quot;)) &#123; //如果access_token已存入缓存，表示请求过 let obj = uni.getStorageSync(&quot;access_token_obj&quot;); let nowTime = new Date().getTime(); if ((nowTime - obj.requestTime) &gt;= 1000 * 3600 * 24 * 30) &#123; //如果上次请求时间在30天之前，则需要重新获取access_token requestAccessToken(res =&gt; &#123; recognition(res, imgData, callback); &#125;); &#125; else &#123; recognition(obj.access_token, imgData, callback); &#125; &#125; else &#123; //缓存中没有access_token requestAccessToken(res =&gt; &#123; recognition(res, imgData, callback); &#125;); &#125;&#125; 123456789101112131415161718//识别中...调用文字识别API,传入图片数据参数function recognition(access_token, imgData, callback) &#123; let params = &#123; access_token: access_token, image: imgData &#125;; let header = &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; //请求头设置成固定值 &#125;; network.request(&apos;https://aip.baidubce.com/rest/2.0/ocr/v1/license_plate&apos;, params, header, &quot;POST&quot;, res =&gt; &#123; callback(res); &#125;, err =&gt; &#123; uni.showToast(&#123; title: &quot;请对准车牌重新拍照&quot;, icon: &quot;none&quot; &#125;) &#125;, &quot;识别中...&quot;);&#125; 只要参数都没有问题，那么接下来就能得到返回结果，返回车牌信息（车牌号、车牌颜色等等）。 调用其他场景的图片识别 API 同理。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>H5 APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序省市区三级联动优化版]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9C%81%E5%B8%82%E5%8C%BA%E4%B8%89%E7%BA%A7%E8%81%94%E5%8A%A8%E4%BC%98%E5%8C%96%E7%89%88%2F</url>
    <content type="text"><![CDATA[优化版的省市区选择器，更简化的 Js 数据，方便输出以及读取显示。js 地址：城市数据 js。 页面组件： 123&lt;picker mode=&quot;multiSelector&quot; bindchange=&quot;bindMultiPickerChange&quot; bindcolumnchange=&quot;bindMultiPickerColumnChange&quot; value=&quot;&#123;&#123;citiesIndex&#125;&#125;&quot; range=&quot;&#123;&#123;cityArray&#125;&#125;&quot; range-key=&quot;name&quot;&gt; &lt;/picker&gt; js 优化后无需放服务器请求，放本地即可。 # 1. 加载城市数据 1var array = require(&apos;../../../utils/cityData.js&apos;).cityData; # 2. 选择器数据初始化 初始化选择器数据，默认都选中第一项。 123456789101112131415161718192021222324252627282930let cityArray = [ [], [], []];for (let x in array[&quot;86&quot;]) &#123; //存入省 cityArray[0].push(&#123; name: array[&quot;86&quot;][x], code: x &#125;);&#125;for (let y in array[cityArray[0][0].code]) &#123; //存入市，默认关联第一个省 cityArray[1].push(&#123; name: array[cityArray[0][0].code][y], code: y &#125;);&#125;for (let z in array[cityArray[1][0].code]) &#123; //存入区，默认关联第一个省的第一个市 cityArray[2].push(&#123; name: array[cityArray[1][0].code][z], code: z &#125;);&#125;this.setData(&#123; cityArray: cityArray&#125;); # 3. 列滚动事件 滚动选择器的列时相应的数据变化，这是最重要的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//列滚动事件 bindMultiPickerColumnChange(e) &#123; let selectedIndex = e.detail.value; let cityArray = this.data.cityArray; let list1 = []; //存放第二列数据，即市的列 let list2 = []; //存放第三列数据，即区的列 let citiesIndex = []; let pcode = &apos;&apos;, scode = &apos;&apos;; let provinceIndex = this.data.citiesIndex[0]; //选中的省索引 let cityIndex = this.data.citiesIndex[1]; //选中的市索引 let areaIndex = this.data.citiesIndex[2]; //选中的区索引 switch (e.detail.column) &#123; case 0: //滚动第一列 pcode = cityArray[0][selectedIndex].code; for(let x in array[pcode])&#123; list1.push(&#123; name: array[pcode][x], code: x &#125;); &#125; scode = list1[0].code; for(let y in array[scode])&#123; list2.push(&#123; name: array[scode][y], code: y &#125;); &#125; citiesIndex = [selectedIndex, 0, 0, 0]; break; case 1: //滚动第二列 list1 = cityArray[1]; scode = list1[selectedIndex].code; for(let x in array[scode])&#123; list2.push(&#123; name: array[scode][x], code: x &#125;); &#125; citiesIndex = [provinceIndex, selectedIndex, 0, 0]; break; case 2: //滚动第三列 list1 = cityArray[1]; list2 = cityArray[2]; citiesIndex = [provinceIndex, cityIndex, selectedIndex, 0]; break; &#125; this.setData(&#123; [`cityArray[1]`]: list1, //重新赋值第二列数组，即联动了市 [`cityArray[2]`]: list2, //重新赋值第三列数组，即联动了区 citiesIndex: citiesIndex, //更新索引 &#125;); # 4. 选择器变更事件 12345678910111213141516171819202122//选择器选择事件 bindMultiPickerChange(e) &#123; let cityIndex = e.detail.value; let cityArray = this.data.cityArray; let province = cityArray[0][cityIndex[0]].name; let city = cityArray[1][cityIndex[1]].name; let district = cityArray[2][cityIndex[2]].name; //选择的地址编码 let areaCode = cityArray[2][cityIndex[2]].code; //选择的地址文本 let selectedAddress = &quot;&quot;; selectedAddress = province + city + district; this.setData(&#123; region: selectedAddress, areaCode: areaCode, provinceCode: cityArray[0][cityIndex[0]].code, cityCode: cityArray[1][cityIndex[1]].code &#125;); &#125;, # 5. 根据传过来的值显示省市区 修改初始化选择器方法，判断当修改地址时读取显示已选择的省市区。 12345678910111213141516171819202122232425262728293031323334353637383940for (let x in array[&quot;86&quot;]) &#123; //存入省 cityArray[0].push(&#123; name: array[&quot;86&quot;][x], code: x &#125;);&#125;if(this.data.address_id != &quot;&quot;)&#123; //编辑地址，根据传过来的地址文本和编码调整选择器 for (let y in array[provinceCode]) &#123; cityArray[1].push(&#123; name: array[provinceCode][y], code: y &#125;); &#125; for (let z in array[cityCode]) &#123; cityArray[2].push(&#123; name: array[cityCode][z], code: z &#125;); &#125; for(let i = 0,len = cityArray[0].length;i&lt;len;i++)&#123; if (cityArray[0][i].code == provinceCode) &#123; provinceIndex = i; &#125; &#125; for (let j = 0, len = cityArray[1].length; j &lt; len; j++) &#123; if (cityArray[1][j].code == cityCode) &#123; cityIndex = j; &#125; &#125; for (let k = 0, len = cityArray[2].length; k &lt; len; k++) &#123; if (cityArray[2][k].code == areaCode) &#123; districtIndex = k; &#125; &#125;&#125; else &#123; //添加地址 # 效果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序长按数量自动加减]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%95%BF%E6%8C%89%E6%95%B0%E9%87%8F%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[开发一个微信小程序，有购物车的功能，在测试加减购物车中商品数量时，发现点一下加一或减一太烦，于是添加了长按自动加减的功能。 页面组件 123&lt;text class="minus" catchtouchstart='startMinus' catchtouchend='endMinus' data-index="&#123;&#123;index&#125;&#125;" data-goodIndex="&#123;&#123;goodIndex&#125;&#125;"&gt;-&lt;/text&gt; &#123;&#123;good.num&#125;&#125; &lt;!-- 商品数量 --&gt;&lt;text class="add" catchtouchstart='startAdd' catchtouchend='endAdd' data-index="&#123;&#123;index&#125;&#125;" data-goodIndex="&#123;&#123;goodIndex&#125;&#125;"&gt;+&lt;/text&gt; # 1. 监听触摸开始事件 首先监听触摸开始事件 touchstart，记录触摸开始时间，时间后面有用。需要用到定时器，timer 用的是页面全局变量。 123456789101112131415161718192021222324//按住加号不停地加startAdd(e)&#123; startTime = new Date().getTime(); //记录触摸开始时间 let index = e.currentTarget.dataset.index; let goodIndex = e.currentTarget.dataset.goodindex; timer = setInterval(()=&gt;&#123; //定义定时器 this.data.cartList[index].goodList[goodIndex].num++; let sumPrice = 0; let count = 0; this.data.cartList.map((type, index) =&gt; &#123; type.goodList.map((good, index) =&gt; &#123; count += good.num; //计算商品数量 if (good.selected) &#123; //计算选中商品价格 sumPrice += good.price * good.num; &#125; &#125;); &#125;); this.setData(&#123; [`cartList[$&#123;index&#125;].goodList[$&#123;goodIndex&#125;]`]: this.data.cartList[index].goodList[goodIndex], //购物车列表内容局部刷新 goodSumPrice: sumPrice, cartNum: count &gt; 99 ? '99+' : count &#125;); &#125;, 100);&#125; # 2. 监听触摸结束事件 触摸结束，则结束数量加减，清除定时器。记录结束时间，和开始时间比较，根据微信小程序官方文档定义：手指触摸后，超过 350ms 再离开为长按。反之则认为是点击，执行点击的逻辑，即数量加一。 12345678//结束加endAdd(e)&#123; endTime = new Date().getTime(); //记录结束时间 if((endTime - startTime) &lt; 350000)&#123; this.clickAdd(e); &#125; clearInterval(timer);&#125; 点击事件逻辑： 123456789101112131415161718192021//点击加号clickAdd(e)&#123; let index = e.currentTarget.dataset.index; let goodIndex = e.currentTarget.dataset.goodindex; this.data.cartList[index].goodList[goodIndex].num ++; let sumPrice = 0; let count = 0; this.data.cartList.map((type, index) =&gt; &#123; type.goodList.map((good, index) =&gt; &#123; count += good.num; if (good.selected) &#123; sumPrice += good.price * good.num; &#125; &#125;); &#125;); this.setData(&#123; [`cartList[$&#123;index&#125;].goodList[$&#123;goodIndex&#125;]`]: this.data.cartList[index].goodList[goodIndex], goodSumPrice: sumPrice, cartNum: count&gt;99?'99+':count &#125;);&#125; 之所以要判断是长按还是点击是因为在标签元素上定义了触摸开始事件后，tap 事件就不再触发，所以需要手动调用点击方法。 减号同理，需要注意数量减到 0 时的操作，我的逻辑是长按数量减到一就停止，再点击减号则删除该商品。 # 效果图]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
</search>
